/**
 * Copyright (c) 2015-2017 YCSB contributors All rights reserved.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License. You
 * may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License. See accompanying
 * LICENSE file.
 */

package com.yahoo.ycsb.measurements;

import com.google.common.util.concurrent.AtomicDouble;
import com.yahoo.ycsb.measurements.exporter.MeasurementsExporter;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.lang.*;

/**
 * Output a series of measurements as raw data points without down sampling,
 * optionally write to an output file when configured. This is an optimized
 * version of OneMeasurementRaw since it does not accumulate the recorded
 * points in a data structure.
 *
 */
public class OneMeasurementRawOptimized extends OneMeasurement {

  /**
   * Optionally, user can configure an output file to save the raw data points.
   * Default is none, raw results will be written to stdout.
   *
   */
  public static final String OUTPUT_FILE_PATH = "measurement.raw.output_file";
  public static final String OUTPUT_FILE_PATH_DEFAULT = "";


  /**
   * This specifies the output path of the temp files generated by this class
   * if the results aren't being written to stdout. This is done to avoid contention
   * between threads, so each one gets to write to its own file.
   *
   */
  public static final String TEMP_FILE_PATH = "measurement.raw.temp_file";
  public static final String TEMP_FILE_PATH_DEFAULT = "/mnt/ramdisk/";

  /**
   * Optionally, user can request to not output summary stats. This is useful
   * if the user chains the raw measurement type behind the HdrHistogram type
   * which already outputs summary stats. But even in that case, the user may
   * still want this class to compute summary stats for them, especially if
   * they want accurate computation of percentiles (because percentils computed
   * by histogram classes are still approximations).
   */
  public static final String NO_SUMMARY_STATS = "measurement.raw.no_summary";
  public static final String NO_SUMMARY_STATS_DEFAULT = "false";

  /**
   * If set to true, YCSB will post-process the results in the end of the experiment
   * to produce the timestamps for request transmission time in nanoseconds (note that
   * these numbers only have millisecond precision)
   */
  public static final String PRINT_DISPATCHING_TIMESTAMPS_PROPERTY = "print_dispatching_timestamps";
  public static final String PRINT_DISPATCHING_TIMESTAMPS_PROPERTY_DEFAULT = "false";

  /**
   * Number of threads used for dumping raw data points (note: if we don't used a dedicated threadpool
   * these threads can be either client threads or I/O threads; in this case, threadcount = 16).
   */
  private static final String RAW_OPTIMIZED_THREADCOUNT = "measurement.raw.threadcount";
  private static final String RAW_OPTIMIZED_THREADCOUNT_DEFAULT = "16";


  private Map<Long,DataOutputStream> outputStreams;

  private static final Map<String, Integer> optToNumEncoding;
  static {
    optToNumEncoding = new HashMap<String, Integer>();
    optToNumEncoding.put("READ", 1);
    optToNumEncoding.put("WRITE", 2);
    optToNumEncoding.put("UPDATE", 3);
    optToNumEncoding.put("CLEANUP", 4);
    optToNumEncoding.put("READ-FAILED", 5);
    optToNumEncoding.put("WRITE-FAILED", 6);
    optToNumEncoding.put("UPDATE-FAILED", 7);
    optToNumEncoding.put("CLEANUP-FAILED", 8);
    optToNumEncoding.put("Intended-READ", 9);
    optToNumEncoding.put("Intended-WRITE", 10);
    optToNumEncoding.put("Intended-UPDATE", 11);
    optToNumEncoding.put("Intended-CLEANUP", 12);
  }

  private static Map<Integer, String> numToOptEncoding;

  private String printFormat = "text";

  private String outputFilePath;

  private String tempFilePath;

  private static String newLine = System.getProperty("line.separator");

  private static boolean print_dispatching_timestamps;

  private int measurementsThreadCount;

  public OneMeasurementRawOptimized(String name, Properties props) {
    super(name);
    System.out.println("Initializing measurements with name: " + name);
    tempFilePath = props.getProperty(TEMP_FILE_PATH, TEMP_FILE_PATH_DEFAULT);
    outputFilePath = props.getProperty(OUTPUT_FILE_PATH, OUTPUT_FILE_PATH_DEFAULT);
    print_dispatching_timestamps = Boolean.parseBoolean(
        props.getProperty(
            PRINT_DISPATCHING_TIMESTAMPS_PROPERTY, PRINT_DISPATCHING_TIMESTAMPS_PROPERTY_DEFAULT));
    if (!outputFilePath.isEmpty()) {
      System.out.println("Raw data measurement: will output to result file: " +
          outputFilePath);
    } else {
      System.out.println("Raw data measurement: will output to stdout.");
    }

    outputStreams = new ConcurrentHashMap<Long,DataOutputStream>();

    measurementsThreadCount = Integer.parseInt(props.getProperty(RAW_OPTIMIZED_THREADCOUNT, RAW_OPTIMIZED_THREADCOUNT_DEFAULT));

    numToOptEncoding = new HashMap<>();
    for(Map.Entry<String, Integer> entry : optToNumEncoding.entrySet()){
      numToOptEncoding.put(entry.getValue(), entry.getKey());
    }
  }

  @Override
  public void measure(int latency) {

    Long recvtimestamp = System.currentTimeMillis();

    try {
      Long threadId = Thread.currentThread().getId();

      if (!outputStreams.containsKey(threadId)) {
        if (!outputFilePath.isEmpty()) {
          outputStreams.put(threadId, new DataOutputStream(new FileOutputStream(
              tempFilePath + threadId + getName() + ".out", true)));
        } else {
          outputStreams.put(threadId, new DataOutputStream(new BufferedOutputStream(System.out)));
        }
        System.out.println(String.format("Creating new Output Stream for the thread [%s]",
          threadId));
      }

      DataOutputStream dos = outputStreams.get(threadId);
      dos.writeByte(getIntName());
      dos.writeLong(recvtimestamp);
      dos.writeInt(latency);

    }
    catch (IOException e) {
        e.printStackTrace();
    }
  }

  public int getIntName() {
    return optToNumEncoding.get(getName());
  }

  @Override
  public void exportMeasurements(MeasurementsExporter exporter)
      throws IOException {

    //once this is triggered, merge all temp files into one
    List<File> inputs = new ArrayList<File>();
    for(Long threadId: outputStreams.keySet()) {
      outputStreams.get(threadId).close();
      inputs.add(new File(tempFilePath + threadId + getName() + ".out"));
    }

    mergeFiles(inputs, new File(outputFilePath + getName()), true);

    //output stats
    Map <String, Integer> stats = getStatistics(outputFilePath + getName());
    for(String name: stats.keySet())
    {
      exporter.write(getName(), name, stats.get(name));
    }

    if (print_dispatching_timestamps) {
      appendRTimestamps(new File(outputFilePath + getName()));
    }
  }

  @Override
  public synchronized String getSummary() {
    return "";
  }

  //compute whatever aggregate statistics we want in the YCSB summaries (post-experiment)
  //TODO: For now we only output operationcount and average latency; we can add more later on
  public Map<String, Integer> getStatistics(String filename)
  {
    Map<String, Integer> stats = new HashMap<>();
    int totalOps = 0;
    long totalLatency = 0;
    try {
      FileInputStream fis = new FileInputStream(filename);
      BufferedReader in = new BufferedReader(new InputStreamReader(fis));
      String aLine;
      while ((aLine = in.readLine()) != null) {
        if (aLine.split(",")[0].equals(getName())) {
          //long timestamp = Long.valueOf(aLine.split(",")[1]);
          int latency = Integer.valueOf(aLine.split(",")[2]);
          totalOps += 1;
          totalLatency += latency;
        }
      }
      int averageLatency = (int)(totalLatency/totalOps);
      stats.put("Total Operations", totalOps);
      stats.put("Average Latency (us)", averageLatency);
      return stats;
    }
    catch(Exception e)
    {
      System.err.println("Oh noes .. we are getting this exception: " + e);
      return stats;
    }
  }

  public static void mergeFiles(List<File> files, File mergedFile, Boolean convertBinarytoText) {

    FileWriter fstream = null;
    BufferedWriter out = null;
    try {
      fstream = new FileWriter(mergedFile, true);
      out = new BufferedWriter(fstream);
    } catch (IOException e1) {
      e1.printStackTrace();
    }

    for (File f : files) {
      System.out.println("merging: " + f.getName());
      FileInputStream fis;
      try {
        fis = new FileInputStream(f);
        if(convertBinarytoText)
        {
          DataInputStream dis = new DataInputStream(fis);
          byte[] byteString = new byte[13];
          while (dis.read(byteString,0,13) != -1) {
            //System.err.println("Line to debug: " + aLine + " has " + byteString.length + " bytes");
            String aLine = String.format("%s,%d,%d", numToOptEncoding.get(byteString[0] & 0xFF),
                ByteBuffer.wrap(Arrays.copyOfRange(byteString, 1, 9)).getLong(),
                ByteBuffer.wrap(Arrays.copyOfRange(byteString, 9, 13)).getInt());
            out.write(aLine);
            out.newLine();
          }
          fis.close();
          f.delete();
        }
        else
        {
          BufferedReader in = new BufferedReader(new InputStreamReader(fis));
          String aLine;
          while ((aLine = in.readLine()) != null) {

            out.write(aLine);
            out.newLine();
          }
          in.close();
          f.delete();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
    }

    try {
      out.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public static void appendRTimestamps(File inputFile) {
    System.err.println("Appending R timestamps to end of outputfile: " + inputFile);
    long minSendTime = Long.MAX_VALUE;
    FileWriter fstream = null;
    BufferedWriter out = null;

    FileInputStream fis;
    try {
      fstream = new FileWriter(new File(inputFile.getPath() + "_temp"), true);
      out = new BufferedWriter(fstream);
      fis = new FileInputStream(inputFile);
      BufferedReader in = new BufferedReader(new InputStreamReader(fis));
      String aLine;

      while ((aLine = in.readLine()) != null) {
        try {
          if(aLine.split(",")[0].equals("READ") || aLine.split(",")[0].equals("UPDATE")) {
            long timestamp = Long.valueOf(aLine.split(",")[1]);
            int latency = Integer.valueOf(aLine.split(",")[2]);
            long sendTime = timestamp - (int) (latency / 1000.0);
            if (sendTime < minSendTime) {
              minSendTime = sendTime;
            }
          }
        } catch (NumberFormatException| ArrayIndexOutOfBoundsException e) {
          //e.printStackTrace();
          out.write("Could not parse line: [" +  aLine + " ]");
        }
      }
      fis = new FileInputStream(inputFile);
      in = new BufferedReader(new InputStreamReader(fis));

      while ((aLine = in.readLine()) != null) {
        try {
          if(aLine.split(",")[0].equals("READ") || aLine.split(",")[0].equals("UPDATE")) {
            long timestamp = Long.valueOf(aLine.split(",")[1]);
            int latency = Integer.valueOf(aLine.split(",")[2]);
            long relativeSendTime = timestamp - (int) (latency / 1000.0) - minSendTime;
            out.write(1 + " R " + relativeSendTime * 1000000);
            out.newLine();
          }
        } catch (NumberFormatException|ArrayIndexOutOfBoundsException e) {
          //e.printStackTrace();
          out.write("Could not parse line: [" +  aLine + " ]");
        }
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
    List<File> dummyList = new ArrayList<File>();
    dummyList.add(new File(inputFile.getPath() + "_temp"));
    mergeFiles(dummyList, inputFile, false);
  }
}
